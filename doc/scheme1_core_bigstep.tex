\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{mathpartir}
%% \usepackage{syntax}

\begin{document}

%% \begin{grammar}
%% <T> ::= i32
%% \alt bool
%% \alt unit
%% \alt (array <T>)
%% \alt (fun ({<T>}) <T>)
%% \end{grammar}

\title{Scheme1 Core Evaluation Semantics}
\maketitle

The Scheme1 core evaluation semantics is given as a three-place
relation between a variable environment $\rho$, expression $e$, and
value $v$, written $\rho \vdash e \Downarrow v$, pronounced ``under
$\rho$, $e$ evaluates to $v$''. Formally, the evaluation semantics is
taken to be the smallest relation closed under the following rules:

\subsubsection*{Variables and values}\vspace{5pt}
\begin{mathpar}
\inferrule [E-val]
           { }
           {\rho \vdash v \Downarrow v}
\and
\inferrule [E-var]
           {\rho(x) = v }
           {\rho \vdash x \Downarrow v}
\end{mathpar}

%% A value evaluates to itself and a variable $x$ steps to value $v$
%% whenever $\rho$ maps $x$ to $v$.

\subsubsection*{Unary operators}\vspace{5pt}
\begin{mathpar}
\inferrule [E-not]
           {\rho \vdash e \Downarrow b}
           {\rho \vdash (\text{not } e) \Downarrow \neg b}
\end{mathpar}

\subsubsection*{Binary operators}\vspace{5pt}
\begin{mathpar}
\inferrule [E-binop]
           {\rho \vdash e_1 \Downarrow n_1 \\
             \rho \vdash e_2 \Downarrow n_2 \\
             n_1 \: b \: n_2 = v \\ b \in \{+, *, -, /, =, <\}}
           {\rho \vdash (b \: e_1 \: e_2) \Downarrow v}
\end{mathpar}

\subsubsection*{Functions}\vspace{5pt}
\begin{mathpar}
\inferrule [E-fun]
           %% {\rho \vdash e_1 \Downarrow \text{clos}(\rho^\prime, x, e_{body}) \\
           %%   \rho \vdash e_2\Downarrow v_2 \\
%%   \rho^\prime[x \mapsto v_2] \vdash e_{body} \Downarrow v}
           { }
           {\rho \vdash (\text{fun } x \: e) \Downarrow clos(\rho, x, e)}
\and
\inferrule [E-app]
%% {\rho \vdash e_1 \Downarrow \text{clos}(\rho_{clos}, x, e_{body}) \\
           {\rho \vdash e_1 \Downarrow \text{clos}(\rho^\prime, x, e_{body}) \\
             \rho \vdash e_2\Downarrow v_2 \\
             %% \rho_{clos}[x \mapsto v_2] \vdash e_{body} \Downarrow v}
             \rho^\prime[x \mapsto v_2] \vdash e_{body} \Downarrow v}
           {\rho \vdash (e_1 \: e_2) \Downarrow v}
\end{mathpar}

%% \subsubsection*{Let expressions}\vspace{5pt}
%% \begin{mathpar}
%% \inferrule [E-let]
%%            {\rho \vdash e_1 \Downarrow v_1 \\
%%              \rho[x \mapsto v_1] \vdash e_2 \Downarrow v_2}
%%            {\rho \vdash (\text{let } x \: e1 \: e_2) \Downarrow v_2}
%% \end{mathpar}

%% \subsubsection*{Recursion}\vspace{5pt}
%% \begin{mathpar}
%% \inferrule [E-fix]
%%            {\rho \vdash e \Downarrow \text{VClos}(\rho_{clos}, x, e_{body}) \\
%%              \rho_{clos}[x \mapsto (\text{fix } \text{VClos}(\rho_{clos}, x, e_{body}))] \vdash e_{body} \Downarrow v}
%%            {\rho \vdash (\text{fix } e) \Downarrow v}
%% \end{mathpar}

\subsubsection*{Conditionals}\vspace{5pt}
\begin{mathpar}
\inferrule [E-if-true]
           {\rho \vdash e_{cond} \Downarrow \text{true} \\
             \rho \vdash e_1 \Downarrow v_1 }
           {\rho \vdash (\text{if } e_{cond} \: e_1 \: e_2) \Downarrow v_1}
\and
\inferrule [E-if-false]
           {\rho \vdash e_{cond} \Downarrow \text{false} \\
             \rho \vdash e_2 \Downarrow v_2}
           {\rho \vdash (\text{if } e_{cond} \: e_1 \: e_2) \Downarrow v_2}
\and
\end{mathpar}

%% \subsubsection*{Products}\vspace{5pt}
%% \begin{mathpar}
%% \inferrule [E-pair]
%%            {\rho \vdash e_1 \Downarrow v_1 \\
%%              \rho \vdash e_2 \Downarrow v_2}
%%            {\rho \vdash (\text{pair } e_1 \: e_2) \Downarrow \text{VPair}(v_1, v_2)}
%% \and
%% \inferrule [E-fst]
%%            {\rho \vdash e \Downarrow \text{VPair}(v_0, v_1)}
%%            {\rho \vdash (\text{fst } e) \Downarrow v_0}
%% \and
%% \inferrule [E-snd]
%%            {\rho \vdash e \Downarrow \text{VPair}(v_0, v_1)}
%%            {\rho \vdash (\text{snd } e) \Downarrow v_1}
%% \end{mathpar}

%% \subsubsection*{Sums}\vspace{5pt}
%% \begin{mathpar}
%% \inferrule [E-inl]
%%            {\rho \vdash e \Downarrow v}
%%            {\rho \vdash (\text{inl } e) \Downarrow \text{VInl}(v)}
%% \and
%% \inferrule [E-inr]
%%            {\rho \vdash e \Downarrow v}
%%            {\rho \vdash (\text{inr } e) \Downarrow \text{VInr}(v)}
%% \and
%% \inferrule [E-case]
%%            {\rho \vdash e_1 \Downarrow \text{VInl}(v_1) \\
%%              \rho \vdash e_2 \Downarrow \text{CVlos}(\rho_0, x, e_{body}) \\
%%              \rho_0[x \mapsto v_1] \vdash e_{body} \Downarrow v_2}
%%            {\rho \vdash (\text{case } e_1 \: e_2 \: e_3) \Downarrow v_2}
%% \end{mathpar}

%% \subsubsection*{Lists}\vspace{5pt}
%% \begin{mathpar}
%% \inferrule [E-cons]
%%            {\rho \vdash e_1 \Downarrow v_1 \\
%%              \rho \vdash e_2 \Downarrow v_2}
%%            {\rho \vdash (\text{cons } e_1 \: e_2) \Downarrow \text{VCons}(v_1, v_2)}
%% \and
%% \inferrule [E-fold-base]
%%            {\rho \vdash e_1 \Downarrow \text{nil} \\
%%              \rho \vdash e_2 \Downarrow v}
%%            {\rho \vdash (\text{fold } e_1 \: e_2 \: e_3) \Downarrow v}
%% \and
%% \inferrule [E-fold-rec]
%%            {\rho \vdash e_1 \Downarrow \text{cons}(v, v_l) \\
%%              \rho \vdash e_2 \Downarrow v_2 \\
%%              \rho \vdash e_3 \Downarrow v_3 \\
%%              \rho \vdash (\text{fold } v_l \: v_2 \: v_3) \Downarrow v \\
%%              \rho \vdash ((v_3 \: v) \: v_l) \Downarrow v'}
%%            {\rho \vdash (\text{fold } e_1 \: e_2 \: e_3) \Downarrow v'}
%% \end{mathpar}

%% \subsubsection*{Printing}\vspace{5pt}
%% \begin{mathpar}
%% \inferrule [E-print]
%%            {\rho \vdash e \Downarrow v}
%%            {\rho \vdash (\text{print } e) \Downarrow tt}
%% \end{mathpar}

%% where $v$ is printed to the terminal output.

\end{document}
